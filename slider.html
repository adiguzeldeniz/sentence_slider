<script>
(async () => {
  // --- Load sentences from sentences.txt ---
  let sentences = [];
  try {
    const resp = await fetch('sentences.txt');
    if (!resp.ok) throw new Error(resp.statusText);
    const text = await resp.text();
    sentences = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  } catch (e) {
    console.error('Could not load sentences.txt:', e);
    sentences = ["(no sentences.txt found)"];
  }

  // --- Randomize order (Fisherâ€“Yates shuffle) ---
  for (let i = sentences.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [sentences[i], sentences[j]] = [sentences[j], sentences[i]];
  }

  // --- Style and parameters from CSS variables ---
  const root = getComputedStyle(document.documentElement);
  const BG    = root.getPropertyValue('--bg').trim()    || '#000';
  const FG    = root.getPropertyValue('--fg').trim()    || '#ff2a2a';
  const DIM   = root.getPropertyValue('--dim').trim()   || '#220000';
  const HCSS  = parseInt(root.getPropertyValue('--height').trim() || '64', 10);
  const SPEED = + (root.getPropertyValue('--speed').trim() || 80);
  const PAUSE = + (root.getPropertyValue('--pause').trim() || 900);
  const LOOP  = (root.getPropertyValue('--loop').trim() || 'true').toLowerCase() !== 'false';
  const FONT  = `'Courier New', Consolas, Monaco, 'DejaVu Sans Mono', monospace`;

  const wrap = document.getElementById('wrap');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const items = sentences.map(s => ({ text:s, off:null }));

  function resize(){
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const Wcss = wrap.clientWidth, Hcss = HCSS;
    canvas.width  = Math.max(1, Math.floor(Wcss * DPR));
    canvas.height = Math.max(1, Math.floor(Hcss * DPR));
    canvas.style.width = Wcss + 'px';
    canvas.style.height = Hcss + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    items.forEach(it => it.off = prerender(it.text));
  }
  addEventListener('resize', resize, {passive:true});

  function prerender(text){
    const off = document.createElement('canvas');
    const offCtx = off.getContext('2d');
    const fontSize = Math.floor(HCSS * 0.68);
    const lineH    = Math.floor(HCSS * 0.78);
    offCtx.font = `${fontSize}px ${FONT}`;
    offCtx.textBaseline = 'middle';
    const w = Math.ceil(offCtx.measureText(text).width) + 4;
    off.width = w; off.height = lineH;
    offCtx.font = `${fontSize}px ${FONT}`;
    offCtx.textBaseline = 'middle';
    offCtx.fillStyle = FG;
    offCtx.fillText(text, 0, Math.floor(lineH/2));
    return { canvas: off, width: w, height: lineH };
  }

  function bg(Wcss,Hcss){
    ctx.fillStyle = BG;  ctx.fillRect(0,0,Wcss,Hcss);
    ctx.fillStyle = DIM; ctx.fillRect(0, Math.floor(Hcss/2), Wcss, 1);
  }

  resize();

  let idx = 0, x = canvas.width / DPR, last = performance.now(), pauseUntil = 0, stopped = false;

  function loop(now){
    const dt = (now - last)/1000; last = now;
    const Wcss = canvas.width / DPR, Hcss = canvas.height / DPR;
    if (stopped) return;

    if (!items[idx].off) items[idx].off = prerender(items[idx].text);
    const img = items[idx].off.canvas;
    const imgW = items[idx].off.width;
    const imgH = items[idx].off.height;
    const y = Math.floor((Hcss - imgH)/2);

    bg(Wcss,Hcss);
    ctx.drawImage(img, Math.floor(x), y);

    if (now < pauseUntil) {
      // waiting between sentences
    } else {
      x -= SPEED * dt;
      if (x <= -imgW) {
        idx += 1;
        if (idx >= items.length) {
          if (LOOP) {
            // reshuffle for new random order on each full cycle
            for (let i = items.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [items[i], items[j]] = [items[j], items[i]];
            }
            idx = 0;
          } else {
            stopped = true;
            return;
          }
        }
        x = Wcss; pauseUntil = now + PAUSE;
      }
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
