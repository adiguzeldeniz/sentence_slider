<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sentence Slider</title>
<style>
  :root{
    --bg:#000;        /* background color */
    --fg:#ff2a2a;     /* text color */
    --dim:transparent;/* faint midline color → now invisible */
    --height:64;      /* px (number only) for the slider bar */
    --speed:80;       /* px/sec */
    --pause:900;      /* ms between sentences */
    --loop:true;      /* true/false */

    /* Hero (GIF) sizing — tweak as you like */
    --hero-max-h: 40vh;   /* cap height relative to viewport */
    --hero-min-h: 160px;  /* ensure it’s never too tiny */
  }

  /* Page base */
  html,body{
    margin:0;
    padding:0;
    background:var(--bg);
    color:var(--fg);
  }

  /* ======= Hero GIF at the top ======= */
  header.hero{
    width:100%;
    overflow:hidden;
    background:var(--bg);
  }
  header.hero img{
    display:block;
    width:100%;
    height:auto;
    max-height:var(--hero-max-h);
  }

  /* ======= Slider row ======= */
  #wrap{
    width:100%;
    height:calc(var(--height) * 1px);
    background:var(--bg);
  }
  canvas{
    display:block;
    width:100%;
    height:100%;
  }
</style>
</head>
<body>

  <!-- TOP GIF -->
  <header class="hero" aria-label="Header animation">
    <img src="coupleonbeach.gif" alt="Animated header" loading="lazy" />
  </header>

  <!-- SLIDER BELOW -->
  <div id="wrap"><canvas id="c"></canvas></div>

<script>
(async () => {
  // --- Load sentences.txt from the same directory ---
  let sentences = [];
  try {
    const resp = await fetch('sentences.txt', { cache: 'no-store' });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();
    sentences = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    if (!sentences.length) throw new Error('sentences.txt is empty');
  } catch (e) {
    console.error('Could not load sentences.txt:', e);
    sentences = ["(sentences.txt not found or empty)"];
  }

  // --- Shuffle once (Fisher–Yates) ---
  for (let i = sentences.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [sentences[i], sentences[j]] = [sentences[j], sentences[i]];
  }

  // --- Read style vars ---
  const css = getComputedStyle(document.documentElement);
  const BG    = css.getPropertyValue('--bg').trim()    || '#000';
  const FG    = css.getPropertyValue('--fg').trim()    || '#ff2a2a';
  const DIM   = css.getPropertyValue('--dim').trim()   || '#220000';
  const HCSS  = parseInt(css.getPropertyValue('--height').trim() || '64', 10);
  const SPEED = + (css.getPropertyValue('--speed').trim() || 80);
  const PAUSE = + (css.getPropertyValue('--pause').trim() || 900);
  const LOOP  = (css.getPropertyValue('--loop').trim() || 'true').toLowerCase() !== 'false';
  const FONT  = `'Courier New', Consolas, Monaco, 'DejaVu Sans Mono', monospace`;

  const wrap = document.getElementById('wrap');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const items = sentences.map(s => ({ text:s, off:null }));

  function resize(){
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const Wcss = wrap.clientWidth, Hcss = HCSS;
    canvas.width  = Math.max(1, Math.floor(Wcss * DPR));
    canvas.height = Math.max(1, Math.floor(Hcss * DPR));
    canvas.style.width  = Wcss + 'px';
    canvas.style.height = Hcss + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    // prerender with current size
    items.forEach(it => { it.off = prerender(it.text); });
  }
  addEventListener('resize', resize, { passive:true });

  function prerender(text){
    const off = document.createElement('canvas');
    const offCtx = off.getContext('2d');
    const fontSize = Math.floor(HCSS * 0.68); // avoids ascender clipping
    const lineH    = Math.floor(HCSS * 0.78);
    offCtx.font = `${fontSize}px ${FONT}`;
    offCtx.textBaseline = 'middle';
    const w = Math.ceil(offCtx.measureText(text).width) + 4;
    off.width = w; off.height = lineH;
    offCtx.font = `${fontSize}px ${FONT}`;
    offCtx.textBaseline = 'middle';
    offCtx.fillStyle = FG;
    offCtx.fillText(text, 0, Math.floor(lineH/2));
    return { canvas: off, width: w, height: lineH };
  }

  function drawBG(W,H){
    ctx.fillStyle = BG;  ctx.fillRect(0,0,W,H);
    ctx.fillStyle = DIM; ctx.fillRect(0, Math.floor(H/2), W, 1);
  }

  function drawError(msg){
    const W = canvas.width / DPR, H = canvas.height / DPR;
    drawBG(W,H);
    ctx.fillStyle = FG;
    ctx.font = `${Math.floor(H * 0.3)}px ${FONT}`;
    ctx.textBaseline = 'middle';
    ctx.fillText(msg, 8, H/2);
  }

  resize();

  if (!items.length) {
    drawError('No sentences to display');
    return;
  }

  let idx = 0, x = canvas.width / DPR, last = performance.now(), pauseUntil = 0, stopped = false;

  function loop(now){
    const dt = (now - last)/1000; last = now;
    const W = canvas.width / DPR, H = canvas.height / DPR;
    if (stopped) return;

    if (!items[idx].off) items[idx].off = prerender(items[idx].text);
    const img = items[idx].off.canvas;
    const imgW = items[idx].off.width;
    const imgH = items[idx].off.height;
    const y = Math.floor((H - imgH)/2);

    drawBG(W,H);
    ctx.drawImage(img, Math.floor(x), y);

    if (now < pauseUntil) {
      // hold
    } else {
      x -= SPEED * dt;
      if (x <= -imgW) {
        idx += 1;
        if (idx >= items.length) {
          if (LOOP) {
            // reshuffle each cycle
            for (let i = items.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [items[i], items[j]] = [items[j], items[i]];
            }
            idx = 0;
          } else {
            stopped = true; return;
          }
        }
        x = W; pauseUntil = now + PAUSE;
      }
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
